<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Christian L. Goueguel">
<meta name="dcterms.date" content="2020-01-07">
<meta name="description" content="High-dimensional data are particularly challenging for outlier detection. Robust PCA methods have been developed to build models that are unaffected by outliers in high dimensions. These outliers are generally characterized by their deviation from the PCA subspace.">

<title>Multivariate Outlier Detection in High-Dimensional Spectral Data – Christian L. Goueguel</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-15f1a39ebb5dcc0ab50acfe4fcc0315b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.scss">
<meta property="og:title" content="Multivariate Outlier Detection in High-Dimensional Spectral Data – Christian L. Goueguel">
<meta property="og:description" content="High-dimensional data are particularly challenging for outlier detection. Robust PCA methods have been developed to build models that are unaffected by outliers in high dimensions. These outliers are generally characterized by their deviation from the PCA subspace.">
<meta property="og:image" content="cover.png">
<meta property="og:site_name" content="Christian L. Goueguel">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Christian L. Goueguel</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../bio.html"> 
<span class="menu-text">ABOUT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../research.html"> 
<span class="menu-text">RESEARCH</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../publications.html"> 
<span class="menu-text">PUBLICATIONS</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../talks.html"> 
<span class="menu-text">TALKS</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../projects/index.html"> 
<span class="menu-text">PROJECTS</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../photography.html"> 
<span class="menu-text">PHOTOGRAPHY</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../blog/index.html"> 
<span class="menu-text">BLOG</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools tools-wide">
    <a href="https://github.com/ChristianGoueguel" title="" class="quarto-navigation-tool px-1" aria-label="" target="_blank"><i class="bi bi-github"></i></a>
    <a href="https://www.linkedin.com/in/christiangoueguel" title="" class="quarto-navigation-tool px-1" aria-label="" target="_blank"><i class="bi bi-linkedin"></i></a>
    <a href="https://scholar.google.ca/citations?user=RTSTmL0AAAAJ&amp;hl=en" title="" class="quarto-navigation-tool px-1" aria-label="" target="_blank"><i class="bi bi-google scholar"></i></a>
    <a href="https://www.researchgate.net/profile/Christian-Goueguel" title="" class="quarto-navigation-tool px-1" aria-label="" target="_blank"><i class="bi bi-r-square"></i></a>
    <a href="https://medium.com/@christian.goueguel" title="" class="quarto-navigation-tool px-1" aria-label="" target="_blank"><i class="bi bi-medium"></i></a>
    <a href="mailto:christian.goueguel@gmail.com" title="" class="quarto-navigation-tool px-1" aria-label="email"><i class="bi bi-envelope-at"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Multivariate Outlier Detection in High-Dimensional Spectral Data</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Chemometrics</div>
    <div class="quarto-category">Machine Learning</div>
    <div class="quarto-category">Outliers</div>
    <div class="quarto-category">Spectroscopy</div>
  </div>
  </div>

<div>
  <div class="description">
    High-dimensional data are particularly challenging for outlier detection. Robust PCA methods have been developed to build models that are unaffected by outliers in high dimensions. These outliers are generally characterized by their deviation from the PCA subspace.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Christian L. Goueguel </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 7, 2020</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div class="justified">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="cover.png" class="img-fluid figure-img"></p>
<figcaption>Photo by <a href="https://unsplash.com/photos/assorted-label-bottle-lot-ku_ttDpqIVc?utm_content=creditShareLink&amp;utm_medium=referral&amp;utm_source=unsplash">Will Myers</a>.</figcaption>
</figure>
</div>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction"><strong>Introduction</strong></h2>
<p>In the realm of <a href="https://science.howstuffworks.com/laser-analysis3.htm">laser spectroscopy</a>, outliers are usually characterized by values that deviate significantly from the values of other observations, abnormally high or low — for example, humidity change, spatial heterogeneity on the samples surface, drift of the instrument parameters, human error, etc. Or by a subtle change in the characteristics of the spectra not taken into account before, since <a href="https://towardsdatascience.com/first-order-multivariate-calibration-in-laser-induced-breakdown-spectroscopy-ca5616dd5b38">calibration models</a> are usually trained on samples with relatively “<em>similar</em>” chemical and physical properties — what we call matrix effects.</p>
<blockquote class="blockquote">
<p>“An outlier is an observation which deviates so much from the other observations as to arouse suspicions that it was generated by a different mechanism.” D. M. Hawkins</p>
</blockquote>
<p>Solutions for the former case — referred to as gross outliers or extreme values — are often straightforward: we fix what was wrong and repeat the measurements if necessary. The latter case is usually more complex and requires advanced statistical methods. However, as discussed later, these subtle changes are often very difficult to detect with traditional methods in addition to being ineffective in high dimensions. The challenge is therefore to find reliable methods which are both:</p>
<ul>
<li>Fast</li>
<li>Robust to outliers or contamination</li>
<li>Applicable to high-dimensional data</li>
</ul>
<p>In high-dimensional space, the data points are very sparse, so that all points are almost equidistant from each other. In other words, the use of Euclidean distances become meaningless. The result is that the degree of outlyingness of data points is indistinguishable from each other. For this reason, outliers are best detected by using a lower-dimensional local subspace in which only a subset of features may be relevant.</p>
<blockquote class="blockquote">
<p>“Outliers are often hidden in the unusual local behavior of low-dimensional subspaces, and this deviant behavior is masked by full-dimensional analysis.” C. C. Aggarwal</p>
</blockquote>
</section>
<section id="mahalanobis-distance" class="level2">
<h2 class="anchored" data-anchor-id="mahalanobis-distance"><strong>Mahalanobis distance</strong></h2>
<p>Standard and widely used distance-based methods consist of computing the Mahalanobis distance. This class of methods only uses distance space to flag outlier observations. The Mahalanobis distance (MD) for the <span class="math inline">\(i\)</span><em>-</em>th observation is given by:</p>
<p><span class="math display">\[
\text{MD}_i = \sqrt{(x_i-\bar{x})^T C^{-1} (x_i-\bar{x})} \quad \text{with} \quad C = \frac{1}{n-1}X^TX
\]</span></p>
<p><span class="math inline">\(X\)</span> is the data matrix of size <span class="math inline">\(n \times p\)</span><em>,</em> where <span class="math inline">\(p\)</span>is the number of variables and <em>n</em> is the number of observations. <span class="math inline">\(x_i\)</span> is an observation (a row of <span class="math inline">\(X\)</span>), <span class="math inline">\(\bar{x}\)</span> is the mean vector, <span class="math inline">\(C\)</span> is the sample covariance matrix which gives information about the covariance structure of the data — i.e.&nbsp;the shape of the ellipsoid specified by the covariance matrix.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-3092986857.png" class="img-fluid figure-img"></p>
<figcaption><strong>FIG. 1:</strong> Robust Mahalanobis distance versus the sample (observation) number.</figcaption>
</figure>
</div>
<p>To identify outlier candidates, MD² is computed and compared to a <strong>cut-off</strong> value equal to the 0.975 quantile of the Chi-Square distributionwith <em>m</em> degrees of freedom, <em>m</em> being the number of variables. This comes from the fact that MD² of multivariate normal data follows a Chi-Square distribution. Albeit, <a href="https://www.jstor.org/stable/27594157?seq=1">Hardin and Rocke (2005)</a> have reported that a better approximation is found using an <em>F</em>-distribution, especially for small sample sizes. Nonetheless, Chi-Square distribution is still reasonably good for approximating the squared Mahalanobis distance. Hence, an observation is considered as an outlier candidate if:</p>
<p><span class="math display">\[
\text{MD}^2 = \chi^2_{m,0.975}
\]</span></p>
<p>However, this approach has two major issues: (1) the arithmetic mean and the sample covariance matrix are sensitive to outliers and (2) the covariance matrix <span class="math inline">\(X^TX\)</span> must be invertible — more formally non singular. The former is solved by applying robust statistics, whilst the latter is obviously a severe limitation for high-dimensional data often encountered in chemometrics where <span class="math inline">\(p \ggg n\)</span><em>.</em> Indeed, the same limitation holds even when one chooses to use the robust version of MD, which is derived from the Minimum Covariance Determinant (MCD) estimator, instead of the classical MD.</p>
</section>
<section id="robust-principal-component-analysis" class="level2">
<h2 class="anchored" data-anchor-id="robust-principal-component-analysis"><strong>Robust Principal Component Analysis</strong></h2>
<p>In chemometrics, Principal Component Analysis (PCA) is widely used for exploratory analysis and for dimensionality reduction and can be used as outlier detection method.</p>
<p>Indeed, PCA score is often used in conjunction with the Mahalanobis distance (or Hotelling’s <span class="math inline">\(T^2\)</span> at 95% confidence level) to determine how far an observation is from the centroid of the elliptical region that encompasses most of the observations.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-4183921573.png" class="img-fluid figure-img"></p>
<figcaption><strong>FIG. 2:</strong> PCA score for the LIBS spectra of plant samples with the 95% confidence limit for Hotelling’s <span class="math inline">\(T^2\)</span>. The transparency level of the data points shows the contribution of each sample to the first component. The darkest samples are those that contribute most.</figcaption>
</figure>
</div>
<p>However, this approach is not robust since classical PCA relies on the sample covariance matrix <strong>C</strong>, and therefore suffers from being extremely sensitive to outliers observations, as can be seen in the above figure. The consequences of this are twofold: on one hand, the variance explained by the principal components is inflated towards the outliers direction and therefore masking observations that deviate from the regular observations — the so-called <strong><em>masking</em></strong> <strong>effect</strong>. On the other hand, regular observations might be falsely flagged as outliers — the so-called <strong><em>swamping</em></strong> <strong>effect</strong>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-1781226141.png" class="img-fluid figure-img"></p>
<figcaption><strong>FIG. 3:</strong> Same PCA score but with the addition of two colors: (red) with and (blue) without measurements error. The former (70 samples) are indistinguishable from error-free measurements (369 samples), although they seem to cluster in the upper right corner which may indicate a similar error.</figcaption>
</figure>
</div>
<p>Hence, to avoid these effects, a number of robustified versions of PCA based upon a robust estimate of the covariance matrix (each characterized by their breakdown point), by means of S-estimator, MM-estimator, (Fast)MCD-estimator or, the re-weighted MCD- (RMCD) estimator have been proposed over the past decades. However, these methods are limited to small or moderate dimensions since the robust estimates are only applicable when the number of observations is at least twice the number of variables <span class="math inline">\((n﹥2p)\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-951674639.png" class="img-fluid figure-img"></p>
<figcaption><strong>FIG. 4:</strong> Robust PCA (Fast-MCD) score for the plant samples. Prior to perform robust PCA, feature selection was carried out to reduce the dimensionality. Here, we can better differentiate the measurements with (red) and without (blue) error. It turns out that the former contribute the most (dark red) to the first component.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-2682877593.png" class="img-fluid figure-img"></p>
<figcaption><strong>FIG. 5:</strong> 3D score plot for the plant samples. Now we can see that the red samples form two separate clusters. The first is clearly separated from error-free measurements, while the second is still difficult to discern but clusters above the regular values.</figcaption>
</figure>
</div>
<p>There is another group of robust PCA methods that have been developed and that are better suited for handling high-dimensional data in the situation where the sample size is lower than the dimension <span class="math inline">\((p \ggg n)\)</span>. These methods are:</p>
<ul>
<li>Robust PCA by projection-pursuit (PP-PCA)</li>
<li>Spherical PCA (SPCA)</li>
<li>Robust PCA (ROBPCA)</li>
<li>Robust Sparse PCA (ROSPCA)</li>
</ul>
<p>The projection-pursuit approach to robust PCA has been initially introduced by <a href="https://www.jstor.org/stable/2288497?seq=1">Li and Chen (1985)</a> and is based on finding the directions that maximize a projection index. PP-PCA uses the median absolute deviation (MAD) or Qn-estimator as projection index instead of the variance. SPCA was derived by <a href="https://link.springer.com/article/10.1007/BF02595862">Locantore <em>et al</em>. (1999)</a> and aims to project data onto the surface of a unit sphere to alleviate outliers effect. Like PP-PCA, SPCA uses MAD or Qn-estimator as a robust estimate of spread.</p>
<p>More recently, ROBPCA and ROSPCA have been introduced by <a href="https://www.tandfonline.com/doi/abs/10.1198/004017004000000563">Hubert <em>et al</em>. 2005</a> and by <a href="https://amstat.tandfonline.com/doi/abs/10.1080/00401706.2015.1093962#.Xgpdb2aZMnU">Hubert <em>et al</em>. 2015</a>. ROBPCA combines the projection pursuit approach with the robust covariance estimation based on the RMCD in a low dimensional space. Interestingly, ROBPCA is much faster than the aforementioned methods and has the advantage to be applicable to both symmetrically distributed data and skewed data (<a href="https://www.sciencedirect.com/science/article/pii/S0167947308002879">Hubert e<em>t al.</em> 2009)</a>. On the other hand, ROSPCA is derived from ROBPCA, but uses Sparse PCA (<a href="https://amstat.tandfonline.com/doi/abs/10.1198/106186006X113430#.Xg90xWaZMnV">Zou <em>et al.</em> 2006</a>) instead of PCA.</p>
</section>
<section id="different-types-of-outliers" class="level2">
<h2 class="anchored" data-anchor-id="different-types-of-outliers"><strong>Different Types of Outliers</strong></h2>
<p>After having briefly reviewed outlier detection methods based upon robust PCA, it is worth mentioning that outliers can be classified into two categories: <strong>Leverage points</strong> and <strong>Orthogonal outliers</strong>. As the figure below illustrates, the leverage points category can be split into <strong>Good</strong> <strong>leverage points</strong> and <strong>Bad leverage points</strong>. As their name suggests, one can have a positive effect while the other has a negative effect.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-702188149.png" class="img-fluid figure-img"></p>
<figcaption><strong>FIG. 6:</strong> Illustration of the different types of outliers on the 2-dimensional PCA subspace. Image credit: Christian Goueguel.</figcaption>
</figure>
</div>
<p>Leverage points and orthogonal outliers are differentiated by their respective <strong>scores and orthogonal distances.</strong> These distances tell us how far an observation is from the center of the ellipse defined by the regular observations (score = 0). The score distance (SD) is a measure of the distance between an observation belonging to the <span class="math inline">\(k\)</span>-dimensional PCA subspace and the origin of that subspace. The orthogonal distance (OD) measures the deviation — <em>i.e.</em> lack of fit — of an observation from the <span class="math inline">\(k\)</span>-dimensional PCA subspace.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-4115846859.png" class="img-fluid figure-img"></p>
<figcaption><strong>FIG. 7:</strong> Illustration of the score and orthogonal distances. Image credit: Christian Goueguel.</figcaption>
</figure>
</div>
<p>Thus, leverage points are characterized by a high score distance, while orthogonal outliers are characterized by a high orthogonal distance. Likewise, good and bad leverage points are differentiated by their respective orthogonal distance. Bad leverage points display higher orthogonal distance than good leverage points.</p>
<p>The score distance for the <span class="math inline">\(i\)</span><em>-</em>th observation on the <span class="math inline">\(k\)</span>-dimensional PCA subspace is given by:</p>
<p><span class="math display">\[
\text{SD}^2_i = \sum^k_{j=1}{\frac{\text{t}^2_{ij}}{l_j}}
\]</span></p>
<p>where <span class="math inline">\(l\)</span> are the eigenvalues of the MCD scatter matrix and <strong>t</strong> are the robust scores, for each <span class="math inline">\(j = 1, \cdots, k\)</span>. Like the Mahalanobis distance, the cut-off values for outlying the squared score distances are obtained from the 0.975 quantile of the Chi-Square distributionwith <span class="math inline">\(k\)</span>degrees of freedom.</p>
<p><span class="math display">\[
\text{SD}^2 &gt;  \chi^2_{k,0.975}
\]</span></p>
<p>The corresponding orthogonal distance is given by:</p>
<p><span class="math display">\[
\text{OD}_i = \| x_i-\hat{\mu}_x - P\times t_i \|
\]</span></p>
<p>where <span class="math inline">\(P\)</span> is the loading matrix, û<em>ₓ</em> is the robust estimate of center. The cut-off values for the orthogonal distances are obtained using the <a href="https://www.rasch.org/rmt/rmt162g.htm">Wilson-Hilferty approximation</a> for a Chi-Squared distribution. As a result, the orthogonal distances, raised to the power 2/3, are approximately normally distributed. Thus, the cut-off values for outliers observations are given by:</p>
<p><span class="math display">\[
\text{OD} &gt; \left[ \text{median}\left(\text{OD}^{2/3} \right) + Z_{0.975}\text{MAD}\left(\text{OD}^{2/3} \right)  \right]^{3/2}
\]</span></p>
<p>where <span class="math inline">\(Z_{0.975}\)</span> is the 0.975 quantile of the Standard Normal distribution.</p>
</section>
<section id="outlier-map" class="level2">
<h2 class="anchored" data-anchor-id="outlier-map"><strong>Outlier map</strong></h2>
<p>Outlier map provides a powerful graphical tool for visually identifying the different types of outliers.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-951014592.png" class="img-fluid figure-img"></p>
<figcaption><strong>FIG. 8:</strong> Illustration of outlier map.</figcaption>
</figure>
</div>
<p>For each observation in the dataset, the score distance and the orthogonal distance are plotted on the <em>x-</em> and <em>y</em>-axis. Their respective cut-off values divide the map into four quadrants:</p>
<ul>
<li>Regular observations are in the bottom left corner of the map,</li>
<li>Orthogonal outliers are in the upper left corner of the map,</li>
<li>Leverage points are on the right side, with good leverage points at the bottom and bad leverage points at the top.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-1113511435.png" class="img-fluid figure-img"></p>
<figcaption><strong>FIG. 9:</strong> Outlier map obtained from ROBPCA using LIBS spectra of plant samples.</figcaption>
</figure>
</div>
<p>The above figure was obtained with ROBPCA. It took 15.86 seconds of execution time (laptop, 2.80GHz) to process the data matrix of size 439×7153. We can see that most of the measurements are in the quadrant of regular observations while some are flagged as orthogonal outliers and bad leverage points. Some of them are good leverage points. On the other hand, the measurements with error are mostly orthogonal outliers, although some are considered regular observations.</p>
</section>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="ChristianGoueguel/christiangoueguel.github.io" data-repo-id="R_kgDONaeuNQ" data-category="General" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<div style="text-align: center;">
<p>© 2024 Christian L. Goueguel. All rights reserved, unless otherwise specified.</p>
</div>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>